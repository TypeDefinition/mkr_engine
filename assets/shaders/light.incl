#version 460 core

float light_attenuation(const in vec3 _pos,
                        const in vec3 _light_pos,
                        const in float _attn_const, const in float _attn_linear, const in float _attn_quad) {
    const vec3 dir = _light_pos - _pos;
    const float dist_sqr = dot(dir, dir);
    const float dist = sqrt(dist_sqr);
    return 1.0f / max(1.0f, _attn_const + (_attn_linear * dist) + (_attn_quad * dist_sqr));
}

float spotlight_effect(const in vec3 _pos,
                       const in vec3 _light_pos, const in vec3 _light_dir,
                       const in float _inner_cos, const in float _outer_cos) {
    const vec3 light_to_frag = normalize(_pos - _light_pos);
    const vec3 spot_direction = normalize(_light_dir);
    const float cosine_angle = dot(light_to_frag, spot_direction);// A·B = |A||B|cos(θ), where |A| = |B| = 1.

    // As long as the angle between the light direction and light_direction is within the inner cosine, the light is at full power. The light power will falloff as it approaches the outer cosine.
    return clamp((cosine_angle - _outer_cos) / (_inner_cos - _outer_cos), 0.0f, 1.0f);
}

float diffuse_intensity(const in vec3 _pos, const in vec3 _normal,
                        const in vec3 _light_pos, const in vec3 _light_dir, bool _is_dir_light) {
    const vec3 frag_to_light = _is_dir_light ? normalize(-_light_dir) : normalize(_light_pos - _pos);
    return clamp(dot(frag_to_light, _normal), 0.0f, 1.0f);
}

float specular_intensity(const in vec3 _pos, const in vec3 _normal,
                         const in vec3 _light_pos, const in vec3 _light_dir, bool _is_dir_light,
                         float _gloss) {
    const vec3 light_to_frag = _is_dir_light ? normalize(_light_dir) : normalize(_pos - _light_pos);
    const vec3 view_dir = normalize(-_pos);
    return pow(max(dot(reflect(light_to_frag, _normal), view_dir), 0.0f), _gloss);
}